#!/usr/bin/perl -w
# $Id: fotofix,v 1.12 2007/03/19 13:10:18 dk Exp $

# simple image viewer with simple capabilities to take care of
# freshly downloaded photos from your camera - can walk image lists,
# rotate images, and remove red eyes (if lucky)
#
# dependencies:
# Prima: http://prima.eu.org/anon_cvs.html ( but will also work with
#  http://search.cpan.org/CPAN/authors/id/K/KA/KARASIK/Prima-1.20.tar.gz )
#
# IPA: http://search.cpan.org/CPAN/authors/id/K/KA/KARASIK/IPA-1.03.tar.gz 
#    (or http://prima.eu.org/IPA/IPA-1.03.tar.gz if CPAN refuses)
#
# optional dependencies:
# Prima::Image::Magick:
#	http://search.cpan.org/~karasik/Prima-Image-Magick-0.02
#  


use strict;
use warnings;
use Prima qw(
	Application ImageViewer StdDlg
	MsgBox IniFile EventHook
);
use IPA::Misc qw(/./);
use IPA::Point qw(/./);
use IPA::Geometry qw(/./);

eval "use Prima::Image::Magick;";
my $UseImageMagick = not $@;

my $VERSION = 0.01;

# If on, can be (not necessarily) , faster but surely will cost extra memory. 
# Since X11 doesn't support scaled image output, this doesn't matter, and should be
# always disabled. Win32 on the contrary does, but might (or might not) be slower
# than Prima native image scaling.
my $UseBufferedZoom =
	( $::application-> get_system_info->{apc} == apc::Unix) ? 0 : 1;

# This is the only parameter the red eye detector cares about, and is a balance of 
# how much green and blue should be there to counterbalance the red. For example,
# 1.0 (default) will remove these red spots where the intensity or red is more
# than sum of intensities of blue and green. $HueDiff less than 1 makes the detector 
# to behave more aggressively, whereas $HueDiff more than 1 makes it be more strict about 
# what is to be considered the red hue. Values outside 0.8-2.0 are probably not
# practically useful.
my $RedEyesHueDiff = 1.0;


my ( 
	$w, $menu, $iv, $image, 
	$ini,
	$want_prebuffered_zoom, $use_prebuffered_zoom,
	@neighbour_files_cache,
	$filename, $filecodec,
	$region, %icons, @window_rect,
	$current_pixel,
	@max_window_size,
);
my $zoom = 1.0;
my $fullscreen_x11 = $::application-> get_system_info->{apc} == apc::Unix;
my $modified   = 0;
my $fullscreen = 0;
my $conversion = ict::Optimized;
my $conversion_menuid = 'P';
my %image_format_category = (
	im::Color                    => '%06x',
	im::GrayScale                => '%d',
	im::GrayScale|im::RealNumber => '%g',
);

{
	$_=<<DD;
z0z0e08d0Fa0Fc0302Cc0F08Fc0F1DFc0F3CFc0F7EF08a0F7EFc07EaF04a07CaFa01069BD041
061BDc0E0BD04a0D07Bc0D16Bc0934Bc0a306c0Ba06z0z0c0zFzFcF0F70cF0E30cF0E10cF0E1
0cF0Ca0cF08a0cFc0F7aFc0F7EFc0F3EFc0F3CFc0F3CF02a0F3EF06a0F3aF0Ea0F7aF0Ca0cF0
810cF0830cF0CF0cFCaF1zFvF
DD
	s/\n//g;
	s/([a-z])?(.)/$2x($1?(ord($1)-ord('_')):1)/ge;
	$_=pack('h*',$_);
	$icons{hand} = Prima::Icon-> create(
		width  => 32,
		height => 32,
		type   => im::BW,
		data   => substr($_,0,128),
		mask   => substr($_,128,128),
	);
	create_pointer( $icons{hand});
}

sub create_pointer
{
	my $i = shift;
	my @p = (
		$::application-> get_system_value( sv::XPointer),
		$::application-> get_system_value( sv::YPointer)
	);
	return if $p[0] <= $i-> width or $p[1] <= $i-> height; # let Prima deal with funky sizes

	# here, we just enlarge the icon without stretching
	$i-> set(
		hScaling => 0,
		vScaling => 0,
	);
	my ( $x, $a) = $i-> split;
	my $aa = $a-> dup;
	$_-> size( @p) for $x, $aa;
	$aa-> data( ~ $aa-> data);
	$aa-> put_image( 0, 0, $a);
	$i-> combine( $x, $aa);
}

sub image_reset_display_buffer
{
	$use_prebuffered_zoom = $want_prebuffered_zoom ? 
		can_use_prebuffered_zoom() : 
		0;

	if ( $use_prebuffered_zoom) {
		my $g;
		if ( $ini-> {Scaling} ne '1') {
			$g = Prima::Image::Magick::prima_to_magick( $image);
			$g-> Resize( 
				width  => int($image-> width  * $zoom),
				height => int($image-> height * $zoom),
				filter => $ini-> {Scaling},
			);
			$g = $g-> Prima;
		} else {
			$g = $image-> dup;
			$g-> size( int($image-> width * $zoom), int($image-> height * $zoom));
		}
		$iv-> zoom( 1.0);
		$iv-> image( $g);
	} else {
		$iv-> image( $image);
		$iv-> zoom( $zoom);
	}
	$iv-> palette( $image-> palette);
}

sub image_replace
{
	my $i = shift;
	$region = undef;

	$image = $i;
	image_reset_display_buffer() unless $ini->{WindowFit} or $ini->{AutoBestFit}; 
	
	$modified = 1;
	update_window_title();
	update_menu_status();
	update_window_size();
}

sub can_use_prebuffered_zoom
{
	return 0 if $ini-> {Scaling} eq '0';
	
	return 0 if $zoom == 1.0; # duh

	return 1 if $ini-> {Scaling} ne '1';

	my @as = $::application-> size;
	return 0 if 
		$zoom * $image-> width  > $as[0] or
		$zoom * $image-> height > $as[1];

	return 0 if int($zoom) == $zoom; # this seems to be good enough for win32 GDI

	1;
}

sub zoom_set
{
	my $old_zoom = $zoom;
	($zoom, $want_prebuffered_zoom) = @_;
	$zoom = 0.02 if $zoom < 0.02;
	$zoom = 100  if $zoom > 100;
	return if $zoom == $old_zoom;

	image_reset_display_buffer();
	update_window_title();
}

# copy-paste from ImageViewer.pm: it cannot do arbitrary zoom factors, only
# with fractional parts from 0.02 to 0.98 with 0.01-0.02 steps
sub zoom_round
{
	my $zoom = shift;
	$zoom = 100 if $zoom > 100;
	$zoom = 1 if $zoom <= 0.01;
	my $dv = int( 100 * ( $zoom - int( $zoom)) + 0.5);
	$dv-- if ($dv % 2) and ( $dv % 5);
	return int($zoom) + $dv / 100;
}
		
# returns zoom factor required to fit the image to the given size
sub zoom_from_window_size
{
	my @xs = @_;
	my @is = $image-> size;
	my @as = $iv-> get_active_area(2, @xs);

	# expect scrollbars to disappear
	$as[0] += $iv-> VScroll-> width  - 1 if $iv-> vScroll;
	$as[1] += $iv-> HScroll-> height - 1 if $iv-> hScroll;

	my $x = $as[0] / $is[0];
	my $y = $as[1] / $is[1];
	my $zoom = ($x < $y) ? $x : $y;
	
	$zoom = zoom_round( $zoom);
	# Zoom roundoffs may create a slighlty larger zoom which might result 
	# in (undesirable) scrollbars. We fight this by reducing zoom factor slightly.
	while ( grep { $xs[$_] < int($is[$_] * $zoom + .5)} (0,1)) {
		my $z = zoom_round( $zoom - 0.01);
		last if $z >= $zoom;
		$zoom = $z;
	}

	return $zoom;
}

sub zoom_scale { zoom_set $zoom * shift }

sub zoom_best_fit
{
	zoom_set( zoom_from_window_size( $iv-> size), 1);
}

sub convert_screen_to_point
{
	return $iv-> screen2point(@_) unless $use_prebuffered_zoom;

	my $ivzoom = $iv-> zoom;
	return map { $_ * $ivzoom / $zoom } $iv-> screen2point(@_);
}

sub convert_point_to_screen
{
	return $iv-> point2screen(@_) unless $use_prebuffered_zoom;
	
	my $ivzoom = $iv-> zoom;
	return $iv-> point2screen( map { $_ * $zoom / $ivzoom } @_);
}

sub region_set
{
	my @r = map { int } ( @_ ? @_ : (0,0,0,0));
	return unless $image;

	my @s = $image-> size;
	@r[0,2] = @r[2,0] if $r[2] < $r[0];
	@r[1,3] = @r[3,1] if $r[3] < $r[1];
	for ( @r) {
		$_ = 0 if $_ < 0;
	}
	$r[0] = 0 if $r[0] < 0;
	$r[1] = 0 if $r[1] < 0;
	$r[2] = $s[0] - 1 if $r[2] >= $s[0];
	$r[3] = $s[1] - 1 if $r[3] >= $s[1];

	@r = (0,0,0,0) if 
		$r[0] >= $s[0] or
		$r[1] >= $s[1] or
		$r[2] < 0 or
		$r[3] < 0 or
		( $r[0] == $r[2] and $r[1] == $r[3]);

	my $r = $region;
	$region = ( grep { $_ != 0 } @r ) ? \@r : undef;

	return if not defined($r) and not defined($region);
	
	$iv-> repaint;
}

sub region_image
{
	$region ? 
		$image-> extract(
			$region->[0],
			$region->[1],
			$region->[2] - $region->[0],
			$region->[3] - $region->[1],
		) : $image;
}

sub draw_marquee
{
	my $o = $::application;
	$o-> begin_paint;
	$o-> rect_focus(
		$iv-> client_to_screen(
			convert_point_to_screen( 
				@{$iv}{qw(x y marquee_x marquee_y)}
			)
		)
	);
	$o-> end_paint;
}

# Try to get maximal window extensions. In case WM resizes us back, 
# record this, and adjust accordingly
sub get_client_size
{
	return @max_window_size if 2 == grep { defined } @max_window_size;

	my @as = $::application-> size;
	$as[0] -= $::application-> get_system_value(sv::XbsSizeable) * 2;
	$as[1] -= $::application-> get_system_value(sv::YbsSizeable) * 2
		+ $::application-> get_system_value(sv::YMenu) 
		+ $::application-> get_system_value(sv::YTitleBar);
	for (0,1) {
		$as[$_] = $max_window_size[$_] if defined $max_window_size[$_];
	}
	@as;
}

sub update_window_title
{
	my $img = $image;
	my $str;
	if ( $img) {
		$str = $filename;
		$str =~ s/([^\\\/]*)$/$1/;
		$str = sprintf("%s (%dx%dx%d bpp)", $1,
			$img-> width, $img-> height, $img-> type & im::BPP);
	} else {
		$str = '.Untitled';
	}

	if ( $iv-> {drag} and $iv->{drag} == mb::Left) {
		$str .= " [" .
			abs( $iv->{marquee_x} - $iv->{x}) .
			":" .
			abs( $iv->{marquee_y} - $iv->{y}) .
			"]";
	} elsif ( defined $current_pixel) {
		$str .= " $current_pixel";
	} else {
		$str .= ' ' . int(100 * $zoom) . '%';
	}

	my $is_modified = $modified ? '* ' : '';
	$w-> text( "FotoFix - $is_modified$str");
	$::application-> name( "FotoFix - $str");
}

sub update_menu_status
{
	my $x = $image ? 1 : 0;
	$menu-> enabled( $_ , $x) for qw(
		saveas next prev first last 
		convert copy view rotate effects
	);

	$x &&= $region;
	$menu-> enabled( $_, $x) for qw(crop redeyes);

	$x = defined $filename;
	$menu-> enabled( $_, $x) for qw(save delete);
}

sub try_max_window_size
{
	return if 2 == grep { defined } @max_window_size;

	my @try_max_size      = ( shift, shift );
	my @adjusted_for_zoom = ( shift, shift );

	my $t = $w-> bring('TryMaxWindowSizeTimer'); # exists already? timing pending?

	$t = $w-> insert( Timer => 
		name    => 'TryMaxWindowSizeTimer',
		timeout => 1,
		onTick => sub {
			my @adjusted_for_zoom = @{$_[0]-> {AdjustedForZoom}};
			my @try_max_size      = @{$_[0]-> {TryMaxSize}};

			$_[0]-> destroy;
			my @actual_size = $iv-> size;

			for ( 0, 1) {
				next if defined $max_window_size[$_];

				if ( $adjusted_for_zoom[$_] > $actual_size[$_]) {
					# window manager reduced the size
					$max_window_size[$_] = $actual_size[$_];
				} elsif ( abs( $try_max_size[$_] - $adjusted_for_zoom[$_]) < 3) {
					# add lax for a couple of pixels for zoom roundoffs, 
					# and record max size as actually reached max size, just
					# to stop further tries
					$max_window_size[$_] = $actual_size[$_];
				}
		}
	} ) unless $t;
	
	$t-> {TryMaxSize}      = \@try_max_size;
	$t-> {AdjustedForZoom} = \@adjusted_for_zoom;
	$t-> start;
}

sub update_window_size
{
	return unless $image;

	if ( $ini->{WindowFit} and not $fullscreen) {
		my @client = get_client_size();
		my $z = zoom_from_window_size( @client);
		my @ivsize = map { int($z * $_ + .5)} $image-> size;
		$w-> set(
			size   => \@ivsize,
			$ini->{AutoPosition} ? 
				( top => $w-> top ) : ()
		);
		try_max_window_size( @client, @ivsize );
		
		my @fs = $w-> frameSize;
		$w-> frameOrigin(0,
			$::application-> height - $fs[1]
		) if $ini->{AutoPosition};
	}
	
	if ( $ini->{WindowFit} or $ini->{AutoBestFit}) {
		zoom_best_fit();
	} elsif ( $ini->{ImageFit} and not $fullscreen) {
		# bring window size to the image's

		my @is = $image-> size;
		
		my @as = get_client_size();

		zoom_set(1.0, 0);
		update_window_title();
		$is[0] = $as[0] if $is[0] > $as[0];
		$is[1] = $as[1] if $is[1] > $as[1];

		for ( 0,1) {
			my @fo = $w-> frameOrigin;
			my @fs1 = $w-> frameSize;
			$w-> set(	
				size => \@is,
				( $ini->{AutoPosition} ? 
					( top => $w-> top ) : ())
			);
			my @fs2 = $w-> frameSize;
			$w-> frameOrigin( $fo[0], $fo[1] + $fs1[1] - $fs2[1])
				if $ini->{AutoPosition};
			# changing frame size is a tricky business, menu might wrap,
			# window manager might behave strangely, etc... give it
			# just one more try to set the minimum client size we want
			my @ws = $w-> size;
			last if $ws[0] >= $is[0] and $ws[1] >= $is[1];
			$is[0] = $ws[0] if $is[0] < $ws[0];
			$is[1] = $ws[1] if $is[1] < $ws[1];
		}
	}
}

sub fitting_set
{
	my ( $self, $type) = @_;

	$ini->{$type} = $menu-> toggle( $type);

	for ( qw(AutoBestFit ImageFit WindowFit)) {
		next if $_ eq $type;
		$ini->{$_} = 0;
		$menu-> uncheck( $_);
	}

	if ( $type ne 'ImageFit' and not $ini->{$type}) {
		$ini->{ImageFit} = 1;
		$menu-> check( 'ImageFit');
	}

	update_window_size();
}

sub scaling_set
{
	my ( $self, $type) = @_;

	my $scaling = $type;
	$scaling =~ s/^Scaling//;

	$menu-> uncheck( 'Scaling' . $ini-> {Scaling});
	$menu-> check( $type, $ini-> {Scaling} = $scaling);

	image_reset_display_buffer() if $image;
}

# In X11 we can only guarantee fullscreen by creating a non-WM-manageable widget.
# This is portable, but we cannot bring dialogs forward, so we must deal with it
# by turning the fullscreen mode off
sub fullscreen_x11
{
	my $f = shift() ? 1 : 0;
	return if $fullscreen == $f;
	if ( $fullscreen = $f) {
		$iv-> set(
			origin      => [0,0],
			size        => [ $::application-> size],
			backColor   => cl::Black,
			owner       => $::application,
		);
	} else {
		$iv-> set(
			origin      => [0,0],
			size        => [ $w-> size],
			backColor   => cl::Back,
			owner       => $w,
		);
	}
	update_window_size();
}

# X11 method doesn't work nice for win32, because the cursed start panel stays in front
# of a non-toplevel widget, but not in front of a top-level window. Go figure. But on
# a positive side, we can stop flipping back from fullscreen mode whenever we need a dialog.
sub fullscreen_win32
{
	my $f = shift() ? 1 : 0;
	return if $fullscreen == $f;
	if ( $fullscreen = $f) {
		@window_rect = $w-> rect;
		$w-> set(
			origin      => [0,0],
			size        => [ $::application-> size],
			backColor   => cl::Black,
			borderIcons => 0,
			borderStyle => bs::None,
		);
		$iv-> backColor( cl::Black);
		$menu-> selected(0);
		$w-> bring_to_front;
	} else {
		$w-> set(
			rect        => \@window_rect,
			backColor   => cl::Back,
			borderIcons => bi::All,
			borderStyle => bs::Sizeable,
		);
		$iv-> backColor( cl::Back);
		$menu-> selected(1);
	}
	update_window_size();
}

sub fullscreen
{
	$fullscreen_x11 ?
		&fullscreen_x11 : 
		&fullscreen_win32;
}

sub open_image
{
	if ( $modified) {
		return unless can_close_image();
	}
	my $dlg  = Prima::ImageOpenDialog-> create(
		directory => $ini-> {Path},
	);
	my $i    = $dlg-> load;
	if ( $i) {
		undef $region;
		$filename = $dlg-> fileName;
		$modified = 0;
		@neighbour_files_cache = ();
		$filecodec = $i-> {extras}->{codecID};
		$ini-> {Path} = $dlg-> directory;

		$zoom = 1.0;
		$image = $i;
		image_reset_display_buffer() unless $ini->{WindowFit} or $ini->{AutoBestFit}; 

		update_window_size();
		update_window_title();
		update_menu_status();
		
		$iv-> update_view;
	}
	$dlg-> destroy;
}

sub open_new_image
{
	my $fn = shift;
	my $i = Prima::Image-> load($fn, loadExtras => 1);
	if ($i) {
		undef $region;
		$filename = $fn;
		$modified = 0;
		@neighbour_files_cache = ();
		$filecodec = $i-> {extras}->{codecID};

		$zoom = 1.0;
		$image = $i;
		image_reset_display_buffer() unless $ini->{WindowFit} or $ini->{AutoBestFit}; 

		update_window_size();
		update_window_title();
		update_menu_status();
		
		$iv-> update_view;
	} else {
		message( "Cannot load image $fn:$@");
	}
}

sub reopen_image
{
	open_new_image($filename) if $filename
}

sub get_dir_list
{
	my ( $basedir, $file) = 
		( $filename =~ /^(.*)[\\\/]([^\\\/]+)$/ ) ?
			($1,$2) :
			('.',$filename);
	my $exts = join('|', map { @{$_->{fileExtensions}} } @{Prima::Image-> codecs});
	my $rx = qr/\.($exts)$/i;
	return unless opendir D, $basedir;
	my @files = grep { /$rx/ } sort readdir D; 
	closedir D;

	my $found;
	for ( my $i = 0; $i < @files; $i++) {
		next unless $files[$i] eq $file;
		$found = $i;
		last;
	}

	return $basedir, $found, @files;
}

sub open_next_image
{
	my ( $self, $menu) = @_;
	
	return if $modified and not can_close_image();

	return unless defined $filename;

	my ( $basedir, $index, @files) = get_dir_list();
	$index ||= 0;

	return message("No files found") unless @files;

	if ( $menu eq 'prev') {
		return open_new_image($neighbour_files_cache[0])
			if $neighbour_files_cache[0];

		if ( $index == 0) {
			return if message("First image in the directory, go to the last?", mb::YesNo) != mb::Yes;
			$index = $#files;
		} else {
			$index--;
		}
	} elsif ( $menu eq 'next') {
		return open_new_image($neighbour_files_cache[1])
			if $neighbour_files_cache[1];

		if ( $index == $#files) {
			return if message("Last image in the directory, go to the first?", mb::YesNo) != mb::Yes;
			$index = 0;
		} else {
			$index++;
		}
	} elsif ( $menu eq 'first') {
		$index = 0;
	} elsif ( $menu eq 'last') {
		$index = $#files;
	}

	open_new_image( "$basedir/$files[$index]");
}

sub save_image
{
	unless ( $image-> save( $filename)) {
		message('Cannot save '.$filename . ":$@");
		return 0;
	}
	$modified = 0;
	update_window_title();
	1;
}

sub save_image_as
{
	my $ok;
	$image-> {extras}->{codecID} = $filecodec;
	my $dlg = Prima::ImageSaveDialog-> create( 
		image     => $image,
		directory => $ini-> {Path},
	);
	if ( $dlg-> save( $image)) {
		$filename = $dlg-> fileName;
		$modified = 0;
		$ok = 1;
		$ini-> {Path} = $dlg-> directory;
		update_window_title();
	}
	$dlg-> destroy;
	$ok;
}

sub delete_image
{
	return unless $filename and
		message("Really delete $filename?", mb::OKCancel) == mb::OK;

	my ( $basedir, $index, @files) = get_dir_list();
	
	unlink $filename or return message("Cannot delete $filename:$!");

	# use this hacky cache to preserve index on the dir list
	$neighbour_files_cache[0] = ( $index > 0) ? $basedir . '/' . $files[$index-1] : undef;
	$neighbour_files_cache[1] = $files[$index+1] ? $basedir . '/' . $files[$index+1] : undef;
}

sub can_close_image
{
	return 1 unless $modified;

	my $ret;
	if ( $filename) {
		$ret = message(
			"Image $filename wasn't saved. Save?",
			mb::YesNoCancel
		);
		return 1 if $ret == mb::Yes and save_image();
	} else {
		$ret = message(
			"Untitled image wasn't saved. Save?",
			mb::YesNoCancel
		);
		return 1 if $ret == mb::Yes and save_image_as();
	}
	return 1 if $ret == mb::No;
	0;
}

sub on_close
{
	shift-> clear_event unless can_close_image()
}

sub iv_mousedown
{
	my ( $self, $btn, $mod, $x, $y) = @_;

	return if $self-> {drag} or not $image;
	
	if ( $btn == mb::Right) {
		$self-> {x} = $x;
		$self-> {y} = $y;
		$self-> {wasdx} = $self-> deltaX;
		$self-> {wasdy} = $self-> deltaY;
		$self-> pointer( $icons{hand});
		$self-> capture(1);
	} elsif ( $btn == mb::Left) {
		@{$self}{qw(x y marquee_x marquee_y)} = map { int } convert_screen_to_point( $x, $y, $x, $y);
		$self-> capture(1, $self);
	} else {
		return;
	}
	
	$self-> {drag} = $btn;
}

sub iv_mouseup
{
	my ( $self, $btn, $mod, $x, $y) = @_;
	return unless $self-> {drag} && $btn == $self->{drag};
	$self-> {drag} = 0;
	$self-> capture(0);
	update_window_title();

	if ( $btn == mb::Right) {
		$self-> pointer( cr::Default);
	} elsif ( $btn == mb::Left) {
		draw_marquee();
		delete @{$self}{qw(marquee_x marquee_y})};
		region_set( @{$self}{qw(x y)}, convert_screen_to_point( $x, $y));
		update_menu_status();
	}
}

sub iv_mousemove
{
	my ( $self, $mod, $x, $y) = @_;

	if ( not $self-> {drag}) {
		if ( $mod & km::Shift) {
			my @p = map { int ( $_ + .5 ) } convert_screen_to_point($x, $y);
			my $p = $image-> pixel( @p);
			
			$current_pixel = ( $p == cl::Invalid) ? 
				undef : 
				sprintf(
					"$p[0]:" . ($image-> height - $p[1]) . ' ' .
						$image_format_category{$image->type & im::Category},
					$image-> pixel( convert_screen_to_point($x, $y))
				);
			update_window_title();
		} elsif ( defined $current_pixel) {
			undef $current_pixel;
			update_window_title();
		}
		
	} elsif ( $self-> {drag} == mb::Right) {
		my ($dx,$dy) = ($x - $self-> {x}, $y - $self-> {y});
		$self-> deltas( $self-> {wasdx} - $dx, $self-> {wasdy} + $dy);
	} elsif ( $self-> {drag} == mb::Left) {
		draw_marquee();
		@{$self}{qw(marquee_x marquee_y)} = map { int } convert_screen_to_point($x, $y);
		draw_marquee();	
		update_window_title();
	}
}

sub iv_keydown
{
	my $self = shift;
	if ( $fullscreen) {
		my ( $code, $key, $mod, $rep) = @_;
		if ( $key == kb::Enter) {
			fullscreen(0);
			$self-> clear_event;
		} else {
			$w-> key_down(@_);
		}
	}
}

sub iv_paint
{
	my ( $self, $canvas) = @_;
	$self-> on_paint( $canvas);
	$canvas-> translate(0,0);
	if ( $fullscreen and $filename) {
		$canvas-> color( cl::LightGreen);
		$canvas-> text_out( $filename, 10, $canvas-> height - $canvas-> font-> width - 10);
	}
	if ( $region) {
		$canvas-> color( cl::Set);
		$canvas-> rop( rop::XorPut);
		$canvas-> rectangle( convert_point_to_screen( @$region));
	}
}

sub iv_size
{
	my ( $self, $ox, $oy, $x, $y) = @_;
	return unless $iv;
	return unless $ini->{WindowFit} or $ini->{AutoBestFit};

	# compress resize events
	return if $self-> bring('ResizeTimer');
	$self-> insert( Timer =>
		name    => 'ResizeTimer',
		timeout => 1,
		onTick  => sub {
			shift-> destroy;
			zoom_best_fit;
		}
	)-> start;
}

sub iv_mousewheel
{
	my ( $self, $mod, $x, $y, $z) = @_;
	$z = int( $z / 120);
	my $xv = ($mod & km::Shift) ? $self-> VScroll : $self-> HScroll;
	$z *= ($mod & km::Ctrl) ? $xv-> pageStep : $xv-> step;
	if ( $mod & km::Shift) {
		$self-> deltaX( $self-> deltaX - $z);
	} else {
		$self-> deltaY( $self-> deltaY - $z);
	}
}

sub conversion_set
{
	my ( $self, $menuID) = @_;
	return if $conversion_menuid eq $menuID;
	$self-> menu-> uncheck( $conversion_menuid);
	$self-> menu-> check( $menuID);
	$conversion_menuid = $menuID;
	$conversion = ( 
		( $menuID eq 'N') ? ict::None : (
		( $menuID eq 'O') ? ict::Ordered : (
		( $menuID eq 'E') ? ict::ErrorDiffusion : ict::Optimized
	))
	);  
}   

sub image_convert
{
	$image-> set(
		conversion => $conversion,
		type       => shift,
	);
	image_replace( $image);
}

sub image_rotate
{
	my $d = shift;
	my $i;
	if ( $d == 90) {
		$i = rotate90( $image, 1);
	} elsif ( $d == 180) {
		$i = rotate180( $image);
	} elsif ( $d == 270) {
		$i = rotate90( $image, 0);
	} else {
		die "invalid call to image_rotate:$d\n";
	}
	image_replace($i);
}

sub image_mirror
{	
	image_replace( mirror( $image, type => 1 + shift));
}

sub image_invert
{
	# could just as well invert the palette if possible, but 
	# probably there are chances that it is data to be inverted...
	
	# doesn't work on floats
	return message('Unimplemented') 
		if im::RealNumber <= ($image-> type & im::Category);

	if ( $region) {
		my $i = region_image();
		$i-> data( ~$i-> data);
		$image-> put_image( @$region[0,1], $i);
	} else {
		$image-> data( ~$image-> data);
	}
	image_replace($image);
}

sub image_remove_red_eyes
{
	return message('Can only work on color images') 
		if im::Color != ($image-> type & im::Category);
	
	my $i = region_image();
	$i-> type( im::RGB); # split_channels accepts RGB only
	my ( $r, $g, $b) = @{split_channels( $i)};
	my ( $G, $B);

	if ( $RedEyesHueDiff < 0.9999 or $RedEyesHueDiff > 1.001) {
		$G = $g-> dup;
		$g-> type(im::Short);
		$g = ab( $g, $RedEyesHueDiff, 0);
		$g = threshold( $g, false => 255, maxvalue => 255, preserve => 1);
		$g-> type(im::Byte);

		$B = $b-> dup;
		$b-> type(im::Short);
		$b = ab( $b, $RedEyesHueDiff, 0);
		$b = threshold( $b, false => 255, maxvalue => 255, preserve => 1);
		$b-> type(im::Byte);
	} else {
		( $G, $B) = ( $g, $b);
	}

	# keep strong red features by subtracting everything green AND blue
	my $x = subtract( $r, $g, conversionType => IPA::conversionTrunc);
	$x = subtract( $x, $b, conversionType => IPA::conversionTrunc);
	# have a binary mask
	$x = threshold( $x, minvalue => 1);
	# cut a hole with the mask in the original red channel
	$r-> rop( rop::NotSrcAnd);
	$r-> put_image( 0, 0, $x);
	# create an averaged green/blue patch
	my $gb = average([ $b, $g ]);
	$gb-> rop( rop::AndPut);
	$gb-> put_image( 0, 0, $x);

	# plaster this patch over a hole in the red channel
	$r-> rop( rop::OrPut);
	$r-> put_image( 0, 0, $gb);
	# combine back
	$i = combine_channels([$r,$G,$B], 'rgb');
	# put the area back to the big image
	$i-> type( $image-> type);
	$image-> put_image( @$region[0,1], $i);

	undef $region;
	image_replace($image);
}

$ini = Prima::IniFile-> create( 
	file    => Prima::Utils::path('FotoFix'),
		default => [
			'Main' => [
				AutoBestFit  => 0,
				WindowFit    => 0,
				ImageFit     => 0,
				Path         => '.',
				AutoPosition => 0,
			],
		],
)-> section('Main');

$w = Prima::Window-> create( menuItems => [
	[ '~File' => [
		['open'   => '~Open image...'  => 'Ctrl+O'       => '^O' => \&open_image],
		['reopen' => '~Reopen image...'=> 'Ctrl+Shift+O' => '^#O' => \&reopen_image],
		['save'   => '~Save image'     => 'Ctrl+S'       => '^S' => \&save_image],
		['saveas' => 'S~ave as...'     => 'Ctrl+Shift+S' => '^#S'=> \&save_image_as],
		[],
		['first'  => '~First image'    => 'Home'         => kb::Home      => \&open_next_image ],
		['next'   => '~Next image'     => 'Space'        => kb::Space     => \&open_next_image ],
		['prev'   => '~Previous image' => 'Backspace'    => kb::Backspace => \&open_next_image ],
		['last'   => '~Last image'     => 'End'          => kb::End       => \&open_next_image ],
		[],
		['delete' => '~Delete file'    => 'Del'          => kb::Delete    => \&delete_image ],
		[],
		['E~xit'          => 'Esc'  => kb::Escape => sub {$::application-> close }],
	]],
	['~Edit' => [
		['copy' => '~Copy' => 'Ctrl+Ins' => km::Ctrl|kb::Insert , sub {
			$::application-> Clipboard-> image(region_image());
		}],
		['~Paste' => 'Shift+Ins' => km::Shift|kb::Insert , sub {
			my $i = $::application-> Clipboard-> image;
			image_replace( $i) if $i;
		}],
		['-crop' => 'Cr~op' => sub {
			return unless $image and $region;
			image_replace( region_image());
		}],
		[],
		[ 'convert' => 'Con~vert to'=> [
			['~Monochrome' => sub {image_convert(im::Mono)}],
			['~16 colors'  => sub {image_convert(im::bpp4)}],
			['~256 colors' => sub {image_convert(im::bpp8)}],
			['~Grayscale'  => sub {image_convert(im::bpp8|im::GrayScale)}],
			['~RGB'        => sub {image_convert(im::RGB)}],
			[],
			['N' => '~No halftoning'   => \&conversion_set],
			['O' => '~Ordered'         => \&conversion_set],
			['E' => '~Error diffusion' => \&conversion_set], 
			['*P' => 'O~ptimized'      => \&conversion_set], 
		]],
		[ 'rotate' => '~Rotate and mirror' => [
			['Rotate ~left' => 'Alt+Left' => km::Alt|kb::Left => sub { image_rotate(90) }],
			['Rotate ~right' => 'Alt+Right' => km::Alt|kb::Right => sub { image_rotate(270) }],
			["Rotate ~180\xB0" => sub { image_rotate(180) }],
			[],
			['Mirror ~vertical' => 'V' => 'v' => sub { image_mirror(1) }],
			['Mirror ~horizontal' => 'H' => 'h' => sub { image_mirror(0) }],
		]],
		['effects' => '~Effects' => [
			['~Invert' => \&image_invert ],
			['-redeyes' => '~Remove red eyes' => 'Alt+R' => '@R' => \&image_remove_red_eyes ],
		]]
	]],
	['view' => '~View' => [
		['~Normal ( 100%)' => 'Ctrl+Z' => '^Z' => sub{zoom_set(1.0)}],
		['F~ull screen' => 'Enter' => kb::Enter => sub {
			fullscreen( not $fullscreen);
		}],
		[ ( $ini->{AutoBestFit} ? '*' : '') .
		'AutoBestFit' => 'Fit to ~window' => 'M' => 'm' => \&fitting_set,
		],[
		( $ini->{WindowFit} ? '*' : '') .
		'WindowFit' => '~Fit to screen' => 'F' => 'f' => \&fitting_set,
		],[ ( $ini->{ImageFit} ? '*' : '') .
		'ImageFit' => 'Fit to ~image' => 'Ctrl+I' => '^I' => \&fitting_set,
		],[ ( $ini->{AutoPosition} ? '*' : '') .
		'AutoPosition' => 'Change window ~position when resizing' => sub {
			$ini->{$_[1]} = $menu-> toggle( $_[1]);
		} ],
		[ '~Scaling' => [
			$UseBufferedZoom ? (
			['Scaling0'         => '~System (unbuffered)'  => \&scaling_set ],
			['Scaling1'         => '~Nearest neighborhood' => \&scaling_set ],
			) : (
			['Scaling0'         => '~Nearest neighborhood' => \&scaling_set ],
			),
			$UseImageMagick ? (
			['ScalingQuadratic' => 'Bi~linear'         => \&scaling_set ],
			['ScalingCubic'     => 'Bi~cubic'          => \&scaling_set ],
			map {
			[ "Scaling$_"       => $_                  => \&scaling_set ]
			} qw( Triangle Hermite Hanning Hamming Blackman Gaussian 
			Catrom Mitchell Lanczos Bessel Sinc)
			) : (
			['Install Prima::Image::Magick for more', sub{}]
			)
		]],
		[],
		['25%' =>   sub{zoom_set 0.25}],
		['~50%' =>  sub{zoom_set 0.5 }],
		['~75%' =>  sub{zoom_set 0.75}],
		['~150%' => sub{zoom_set 1.5 }],
		['~200%' => sub{zoom_set 2   }],
		['~300%' => sub{zoom_set 3   }],
		['~400%' => sub{zoom_set 4   }],
		['~600%' => sub{zoom_set 6   }],
		['16~00%' =>sub{zoom_set 16  }],
		[],
		['~Increase' => '+' => '+' => sub { zoom_scale 1.1 }],
		['~Decrease' => '-' => '-' => sub { zoom_scale 0.9 }],
	]],
	[],
	['~Help' => [
		["~Information" => "F1" => "F1" => sub { $::application-> open_help($0)}],
         	[],
		[ "~About" => sub { message <<ABOUT, mb::OK }],
FotoFix v$VERSION by Dmitry Karasik

A simple image viewer
ABOUT
	]]],

	accelItems => [
		[ quit => quit => q => sub {$::application-> close }],
	],

	icon      => Prima::StdBitmap::icon(0),
	visible   => 0,
	onClose   => \&on_close,
	onDestroy => sub { $::application-> destroy },
);

$menu = $w-> menu;

$iv = $w-> insert( ImageViewer =>
	size	    => [ $w-> size],
	origin      => [ 0, 0],
	growMode    => gm::Client,
	quality     => 1,
	selectable  => 1,
	name        => 'IV',
	valignment  => ta::Middle,
	alignment   => ta::Center,
	onMouseDown => \&iv_mousedown,
	onMouseUp   => \&iv_mouseup,
	onMouseMove => \&iv_mousemove,
	onPaint     => \&iv_paint,
	onSize      => \&iv_size,

	( $fullscreen_x11 ? (
	onKeyDown   => \&iv_keydown
	) : ()),
);

Prima::EventHook::install( 
	sub { fullscreen(0) },
	event  => 'Execute',
) if $fullscreen_x11;

$ini-> {Scaling} = $UseBufferedZoom 
	unless exists $ini-> {Scaling} and $menu-> has_item( 'Scaling' . $ini-> {Scaling});
scaling_set( $w, 'Scaling' . $ini-> {Scaling});

update_menu_status();
update_window_title();
update_window_size();
if ( @ARGV) {
	if ( -f $ARGV[0]) {
		open_new_image( $ARGV[0]);
	} elsif ( -d $ARGV[0]) {
		$filename = "$ARGV[0]/.";
		open_next_image($w, 'next');
	} else {
		message("$ARGV[0] cannot be opened");
	}
}

$w-> show;
$w-> select;

# uncomment this for simple benchmarking
# open_next_image($w,'next') for 0..20; exit; 

run Prima;

exit;
1;

__DATA__

=pod

=head1 NAME

FotoFix - simple image viewer

=head1 DESCRIPTION

FotoFix is a simple image viewer with simple capabilities to take care of
freshly downloaded photos from your camera - can walk image lists, rotate
images, and remove red eyes (if lucky). It was inspired by IrfanView for
Windows, a great but unfortunately non-portable and closed-source product.
My experience with various image viewers came to a point where I was no 
longer satisfied with any, so I wrote yet another one.

=head1 INSTALLATION

FotoFix requres L<perl>, L<Prima>, and L<IPA> as dependencies. Whereas the
first can be obtained by typing "download perl" in Google, the latter are
available from CPAN.

=head1 USAGE

=head2 Remove red eyes

To remove red eyes, select a rectangular area by mouse and do
"Edit/Effects/Remove red eyes".  This will hopefully eliminate red spots in the
given rectangle. If there are false positives, try to reload the image and
apply the operation to a smaller area. The algorithm for reducing red eye glow
is very simple, so if you have some bad red eyes, not detectable by it, feel
free to hack it.

=head2 Show pixel value under cursor

Press shift and move the mouse around the picture

=head1 BUGS & FEATURES

The viewer is very, very simple. If you find a bug, or miss a feature, you
are very welcome to hack it as you like, and eventually send me a patch.

=head1 LICENSE

This software is distributed under BSD license

=head1 AUTHOR

Dmitry Karasik, E<lt>dmitry@karasik.eu.orgE<gt>.

=cut
